<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Java(Spring Boot) 백엔드 개발자를 위한 Trade AI 서비스 중계 구현 및 React
      연동 가이드 - SSE 스트리밍 중계 & Redis 신뢰성 큐 패턴
    </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              "code-bg": "#1e293b",
              "code-text": "#e2e8f0",
            },
          },
        },
      };
    </script>
  </head>
  <body class="bg-gray-50 text-gray-900">
    <!-- Header -->
    <header
      class="bg-gradient-to-r from-blue-600 to-purple-600 text-white shadow-lg"
    >
      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <h1 class="text-4xl font-bold mb-4">
          Java(Spring Boot) 백엔드 개발자를 위한
        </h1>
        <h2 class="text-3xl font-semibold mb-2">
          Trade AI 서비스 구현 및 React 연동 가이드
        </h2>
        <p class="text-xl opacity-90">
          Python AI 서버 중계를 통한 안정적이고 확장 가능한 Java 백엔드 구축 -
          SSE 스트리밍 중계 & Redis 신뢰성 큐 패턴
        </p>
        <div class="mt-6 flex flex-wrap gap-2">
          <span class="bg-white bg-opacity-20 px-3 py-1 rounded-full text-sm"
            >Spring Boot 3.x</span
          >
          <span class="bg-white bg-opacity-20 px-3 py-1 rounded-full text-sm"
            >SseEmitter</span
          >
          <span class="bg-white bg-opacity-20 px-3 py-1 rounded-full text-sm"
            >Redis 신뢰성 큐</span
          >
          <span class="bg-white bg-opacity-20 px-3 py-1 rounded-full text-sm"
            >SSE 스트리밍</span
          >
          <span class="bg-white bg-opacity-20 px-3 py-1 rounded-full text-sm"
            >React</span
          >
        </div>
      </div>
    </header>

    <!-- Navigation -->
    <nav class="bg-white shadow-md sticky top-0 z-50">
      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between items-center py-4">
          <div class="text-lg font-semibold text-gray-800">목차</div>
          <button
            id="mobile-menu-btn"
            class="md:hidden bg-gray-100 p-2 rounded-md"
          >
            <svg
              class="w-6 h-6"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 6h16M4 12h16M4 18h16"
              ></path>
            </svg>
          </button>
        </div>
        <div id="nav-menu" class="hidden md:block pb-4">
          <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm">
            <a
              href="#overview"
              class="text-blue-600 hover:text-blue-800 font-medium"
              >1. 개요</a
            >
            <a
              href="#architecture"
              class="text-blue-600 hover:text-blue-800 font-medium"
              >2. 아키텍처 분석</a
            >
            <a
              href="#java-implementation"
              class="text-blue-600 hover:text-blue-800 font-medium"
              >3. Java 구현 가이드</a
            >
            <a
              href="#react-integration"
              class="text-blue-600 hover:text-blue-800 font-medium"
              >4. React 연동</a
            >
          </div>
        </div>
      </div>
    </nav>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <!-- Overview Section -->
      <section id="overview" class="mb-16">
        <div class="bg-white rounded-lg shadow-lg p-8">
          <h2
            class="text-3xl font-bold text-gray-900 mb-6 border-b-2 border-blue-500 pb-3"
          >
            1. 개요
          </h2>

          <div class="grid md:grid-cols-2 gap-8 mb-8">
            <div class="bg-blue-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-blue-800 mb-4">
                📋 문서의 목적
              </h3>
              <p class="text-gray-700 leading-relaxed">
                이 문서는 기존 Python(FastAPI)으로 구현된 "Trade AI Service"와
                Java(Spring Boot) 환경에서 중계 서버를 구현하고 최종적으로 React
                프론트엔드와 안정적으로 연동하는 것을 목표로 하는
                <strong>Java 백엔드 개발자를 위한 종합 기술 가이드</strong
                >입니다.
              </p>
            </div>

            <div class="bg-green-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-green-800 mb-4">
                🎯 핵심 목표
              </h3>
              <ul class="text-gray-700 space-y-2">
                <li class="flex items-start">
                  <span class="text-green-600 mr-2">✓</span>
                  Python AI 서버와 React 클라이언트 사이의 중계 아키텍처 구현
                </li>
                <li class="flex items-start">
                  <span class="text-green-600 mr-2">✓</span>
                  WebClient + SseEmitter를 활용한 SSE 스트리밍 중계
                </li>
                <li class="flex items-start">
                  <span class="text-green-600 mr-2">✓</span>
                  안정적이고 확장 가능한 중계 시스템 구축
                </li>
              </ul>
            </div>
          </div>

          <!-- New Architecture Flow Diagram -->
          <div
            class="bg-gradient-to-r from-indigo-50 to-blue-50 p-8 rounded-lg mb-8"
          >
            <h3 class="text-2xl font-semibold text-indigo-800 mb-6">
              🏗️ 중계 아키텍처 플로우
            </h3>
            <div class="bg-white p-6 rounded-lg shadow-sm">
              <div
                class="flex flex-col md:flex-row items-center justify-between space-y-4 md:space-y-0"
              >
                <div class="text-center">
                  <div
                    class="bg-blue-100 text-blue-800 px-4 py-3 rounded-lg font-semibold"
                  >
                    React 클라이언트
                  </div>
                  <div class="text-sm text-gray-600 mt-2">포트: 3000</div>
                </div>

                <div class="text-center">
                  <div class="text-blue-600 font-bold text-2xl">→</div>
                  <div class="text-xs text-gray-500">POST /api/chat</div>
                  <div class="text-xs text-gray-500">
                    Accept: text/event-stream
                  </div>
                </div>

                <div class="text-center">
                  <div
                    class="bg-green-100 text-green-800 px-4 py-3 rounded-lg font-semibold"
                  >
                    Java Spring Boot
                  </div>
                  <div class="text-sm text-gray-600 mt-2">
                    포트: 8080 (중계 서버)
                  </div>
                </div>

                <div class="text-center">
                  <div class="text-green-600 font-bold text-2xl">→</div>
                  <div class="text-xs text-gray-500">POST /api/v1/chat</div>
                  <div class="text-xs text-gray-500">WebClient SSE</div>
                </div>

                <div class="text-center">
                  <div
                    class="bg-purple-100 text-purple-800 px-4 py-3 rounded-lg font-semibold"
                  >
                    Python AI 서버
                  </div>
                  <div class="text-sm text-gray-600 mt-2">
                    포트: 8000 (AI 처리)
                  </div>
                </div>
              </div>

              <div
                class="mt-6 flex flex-col md:flex-row items-center justify-between space-y-4 md:space-y-0"
              >
                <div class="text-center">
                  <div class="text-blue-600 font-bold text-2xl">←</div>
                  <div class="text-xs text-gray-500">SseEmitter</div>
                  <div class="text-xs text-gray-500">실시간 스트리밍</div>
                </div>

                <div class="text-center">
                  <div class="text-green-600 font-bold text-2xl">←</div>
                  <div class="text-xs text-gray-500">
                    bodyToFlux(String.class)
                  </div>
                  <div class="text-xs text-gray-500">SSE 청크 수신</div>
                </div>

                <div class="text-center">
                  <div class="text-purple-600 font-bold text-2xl">←</div>
                  <div class="text-xs text-gray-500">StreamingResponse</div>
                  <div class="text-xs text-gray-500">AI 토큰 생성</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Technology Stack -->
          <div class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">
              기술 스택 매핑
            </h3>
            <div class="overflow-x-auto">
              <table class="w-full border-collapse border border-gray-300">
                <thead class="bg-gray-100">
                  <tr>
                    <th
                      class="border border-gray-300 px-4 py-3 text-left font-semibold"
                    >
                      컴포넌트
                    </th>
                    <th
                      class="border border-gray-300 px-4 py-3 text-left font-semibold"
                    >
                      Python (기존)
                    </th>
                    <th
                      class="border border-gray-300 px-4 py-3 text-left font-semibold"
                    >
                      Java (구현)
                    </th>
                    <th
                      class="border border-gray-300 px-4 py-3 text-left font-semibold"
                    >
                      역할
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr class="hover:bg-gray-50">
                    <td class="border border-gray-300 px-4 py-3 font-medium">
                      웹 프레임워크
                    </td>
                    <td class="border border-gray-300 px-4 py-3">FastAPI</td>
                    <td class="border border-gray-300 px-4 py-3">
                      Spring Boot + WebFlux
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      비동기 API 서버
                    </td>
                  </tr>
                  <tr class="hover:bg-gray-50">
                    <td class="border border-gray-300 px-4 py-3 font-medium">
                      스트리밍
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      StreamingResponse (SSE)
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      SseEmitter / Flux&lt;ServerSentEvent&gt;
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      실시간 AI 채팅 응답
                    </td>
                  </tr>
                  <tr class="hover:bg-gray-50">
                    <td class="border border-gray-300 px-4 py-3 font-medium">
                      분산 락
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      Redis SET NX
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      Redisson RLock
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      동시 실행 제어
                    </td>
                  </tr>
                  <tr class="hover:bg-gray-50">
                    <td class="border border-gray-300 px-4 py-3 font-medium">
                      메시지 큐
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      Redis BLMOVE
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      RedisTemplate + BLMOVE
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      신뢰성 큐 패턴
                    </td>
                  </tr>
                  <tr class="hover:bg-gray-50">
                    <td class="border border-gray-300 px-4 py-3 font-medium">
                      속도 제어
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      Aiolimiter + Tenacity
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      Resilience4J
                    </td>
                    <td class="border border-gray-300 px-4 py-3">
                      Rate Limiting + Retry
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Expected Benefits -->
          <div
            class="bg-gradient-to-r from-purple-50 to-pink-50 p-6 rounded-lg"
          >
            <h3 class="text-xl font-semibold text-purple-800 mb-4">
              🚀 기대 효과
            </h3>
            <div class="grid md:grid-cols-3 gap-4">
              <div class="bg-white p-4 rounded-lg shadow-sm">
                <h4 class="font-semibold text-purple-700 mb-2">명확성</h4>
                <p class="text-sm text-gray-600">
                  Java 개발자가 프로젝트의 목표와 기술적 요구사항을 명확히 이해
                </p>
              </div>
              <div class="bg-white p-4 rounded-lg shadow-sm">
                <h4 class="font-semibold text-purple-700 mb-2">안정성</h4>
                <p class="text-sm text-gray-600">
                  검증된 아키텍처 패턴으로 시스템 안정성과 데이터 정합성 보장
                </p>
              </div>
              <div class="bg-white p-4 rounded-lg shadow-sm">
                <h4 class="font-semibold text-purple-700 mb-2">생산성</h4>
                <p class="text-sm text-gray-600">
                  검증된 라이브러리와 구현 예시로 개발 시간 단축
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Architecture Analysis Section -->
      <section id="architecture" class="mb-16">
        <div class="bg-white rounded-lg shadow-lg p-8">
          <h2
            class="text-3xl font-bold text-gray-900 mb-6 border-b-2 border-blue-500 pb-3"
          >
            2. 아키텍처 분석
          </h2>

          <div class="grid md:grid-cols-2 gap-8 mb-8">
            <div class="bg-blue-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-blue-800 mb-4">
                🔗 아키텍처 개요
              </h3>
              <p class="text-gray-700 leading-relaxed">
                Java 백엔드는 React 클라이언트와 Python AI 서버 사이의 중계
                역할을 하며, 더 나은 확장성과 안정성을 제공합니다. 주요 구성
                요소는 다음과 같습니다:
              </p>
              <ul class="text-gray-700 space-y-2">
                <li class="flex items-start">
                  <span class="text-blue-600 mr-2">•</span>
                  웹 프레임워크: Spring Boot + SseEmitter (클라이언트 → Java)
                </li>
                <li class="flex items-start">
                  <span class="text-blue-600 mr-2">•</span>
                  스트리밍 중계: WebClient + SSE (Java → Python → Java → React)
                </li>
                <li class="flex items-start">
                  <span class="text-blue-600 mr-2">•</span>
                  분산 락: Redisson RLock - 모니터링 동시 실행 제어
                </li>
                <li class="flex items-start">
                  <span class="text-blue-600 mr-2">•</span>
                  메시지 큐: Redis BLMOVE - 신뢰성 큐 패턴
                </li>
                <li class="flex items-start">
                  <span class="text-blue-600 mr-2">•</span>
                  외부 연동: WebClient - Python AI 서버 통신
                </li>
              </ul>
            </div>

            <div class="bg-green-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-green-800 mb-4">
                🔗 SSE 스트리밍
              </h3>
              <p class="text-gray-700 leading-relaxed">
                Java Spring Boot가 Python AI 서버와 React 클라이언트 사이의 중계
                역할을 합니다. WebClient로 Python AI 서버의 SSE 스트림을 받아서
                SseEmitter로 클라이언트에게 실시간으로 전달합니다.
              </p>
              <pre class="bg-gray-100 p-4 rounded-md text-sm">
                <code class="language-java">
                  @PostMapping(produces = MediaType.TEXT_EVENT_STREAM_VALUE)
                  public SseEmitter streamChat(@RequestBody ChatRequest request) {
                      SseEmitter emitter = new SseEmitter(300000L);
                      
                      CompletableFuture.runAsync(() -> {
                          try {
                              // Python AI 서버로 SSE 스트림 요청
                              pythonAiWebClient.post()
                                  .uri("/api/v1/chat")
                                  .contentType(MediaType.APPLICATION_JSON)
                                  .accept(MediaType.TEXT_EVENT_STREAM)
                                  .bodyValue(request)
                                  .retrieve()
                                  .bodyToFlux(String.class)
                                  .doOnNext(chunk -> {
                                      try {
                                          // Python 서버의 SSE 청크를 클라이언트로 중계
                                          emitter.send(SseEmitter.event().data(chunk));
                                      } catch (IOException e) {
                                          log.error("SSE 전송 오류", e);
                                      }
                                  })
                                  .doOnComplete(() -> emitter.complete())
                                  .doOnError(error -> emitter.completeWithError(error))
                                  .subscribe();
                          } catch (Exception e) {
                              emitter.completeWithError(e);
                          }
                      });
                      
                      return emitter;
                  }
                </code>
              </pre>
            </div>

            <div class="bg-purple-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-purple-800 mb-4">
                🔗 Redis 분산 락
              </h3>
              <p class="text-gray-700 leading-relaxed">
                Redisson RLock은 Redis를 사용한 분산 락 구현체입니다. 여러
                서버에서 동시에 동일한 자원에 접근하는 경우, 락을 통해 동기화를
                보장할 수 있습니다.
              </p>
              <pre class="bg-gray-100 p-4 rounded-md text-sm">
                <code class="language-java">
                  RLock lock = redissonClient.getLock("myLock");
                  boolean isLocked = lock.tryLock(10, TimeUnit.SECONDS);
                  if (isLocked) {
                      try {
                          // 임계 영역 코드
                      } finally {
                          lock.unlock();
                      }
                  }
                </code>
              </pre>
            </div>

            <div class="bg-orange-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-orange-800 mb-4">
                🔗 신뢰성 큐 패턴
              </h3>
              <p class="text-gray-700 leading-relaxed">
                Redis BLMOVE는 신뢰성 큐 패턴의 핵심으로, 작업을 대기 큐에서
                처리 중 큐로 원자적으로 이동시킵니다. 모니터링 시스템에서 발견된
                업데이트를 알림 큐에 추가하면, Spring Boot 워커가 이를 안전하게
                처리합니다.
              </p>
              <pre class="bg-gray-100 p-4 rounded-md text-sm">
                <code class="language-java">
                  // 알림 작업 생성 (Producer - Python AI 서버)
                  String queueKey = "daily_notification:queue:EMAIL";
                  String notificationUuid = UUID.randomUUID().toString();
                  redisTemplate.opsForList().leftPush(queueKey, notificationUuid);
                  
                  // 알림 작업 처리 (Consumer - Java Spring Boot)
                  String processingKey = "daily_notification:processing_queue:EMAIL";
                  String taskId = redisTemplate.opsForList().rightPopAndLeftPush(
                      queueKey, processingKey, Duration.ofSeconds(10));
                </code>
              </pre>
            </div>
          </div>
        </div>
      </section>

      <!-- Java Implementation Guide Section -->
      <section id="java-implementation" class="mb-16">
        <div class="bg-white rounded-lg shadow-lg p-8">
          <h2
            class="text-3xl font-bold text-gray-900 mb-6 border-b-2 border-blue-500 pb-3"
          >
            3. Java 구현 가이드
          </h2>

          <div class="grid md:grid-cols-2 gap-8 mb-8">
            <div class="bg-blue-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-blue-800 mb-4">
                🔗 의존성 설정
              </h3>
              <p class="text-gray-700 leading-relaxed">
                Spring Boot 3.x 프로젝트에서 필요한 주요 의존성을 포함합니다.
              </p>
              <pre class="bg-gray-100 p-4 rounded-md text-sm">
                <code class="language-xml">
                  &lt;project&gt;
                    &lt;dependencies&gt;
                      &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
                      &lt;/dependency&gt;
                      &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
                      &lt;/dependency&gt;
                      &lt;dependency&gt;
                        &lt;groupId&gt;io.projectreactor.netty&lt;/groupId&gt;
                        &lt;artifactId&gt;reactor-netty&lt;/artifactId&gt;
                      &lt;/dependency&gt;
                      &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
                      &lt;/dependency&gt;
                      &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
                      &lt;/dependency&gt;
                      &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
                      &lt;/dependency&gt;
                      &lt;dependency&gt;
                        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
                        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
                      &lt;/dependency&gt;
                    &lt;/dependencies&gt;
                  &lt;/project&gt;
                </code>
              </pre>
            </div>

            <div class="bg-green-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-green-800 mb-4">
                🔗 기본 구성
              </h3>
              <p class="text-gray-700 leading-relaxed">
                Spring Boot 3.x 프로젝트의 기본 구조와 필요한 클래스를
                포함합니다.
              </p>
              <pre class="bg-gray-100 p-4 rounded-md text-sm">
                <code class="language-java">
                  import org.springframework.boot.SpringApplication;
                  import org.springframework.boot.autoconfigure.SpringBootApplication;
                  import org.springframework.context.annotation.Bean;
                  import org.springframework.web.reactive.function.client.WebClient;
                  import org.springframework.data.redis.connection.RedisConnectionFactory;
                  import org.springframework.data.redis.core.RedisTemplate;
                  import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
                  import org.springframework.data.redis.serializer.StringRedisSerializer;
                  import org.redisson.Redisson;
                  import org.redisson.api.RedissonClient;
                  import org.redisson.config.Config;
                  import reactor.netty.http.client.HttpClient;
                  import org.springframework.http.client.reactive.ReactorClientHttpConnector;
                  import io.netty.channel.ChannelOption;
                  import java.time.Duration;

                  @SpringBootApplication
                  @EnableRedisRepositories
                  @EnableScheduling
                  public class TradeAiApplication {

                      public static void main(String[] args) {
                          SpringApplication.run(TradeAiApplication.class, args);
                      }

                      @Bean
                      public WebClient pythonAiWebClient() {
                          return WebClient.builder()
                              .baseUrl("http://localhost:8000") // Python AI 서버 URL
                              .codecs(configurer -> {
                                  configurer.defaultCodecs().maxInMemorySize(1024 * 1024); // 1MB
                              })
                              .clientConnector(new ReactorClientHttpConnector(
                                  HttpClient.create()
                                      .responseTimeout(Duration.ofSeconds(120))
                                      .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)
                              ))
                              .build();
                      }

                      @Bean
                      public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
                          RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();
                          template.setConnectionFactory(connectionFactory);
                          template.setKeySerializer(new StringRedisSerializer());
                          template.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));
                          return template;
                      }

                      @Bean
                      public RedissonClient redissonClient() {
                          Config config = new Config();
                          config.useSingleServer()
                              .setAddress("redis://localhost:6379") // Redis 서버 주소
                              .setConnectionMinimumIdleSize(2)
                              .setConnectionPoolSize(8)
                              .setRetryAttempts(3)
                              .setRetryInterval(1500);
                          return Redisson.create(config);
                      }
                  }
                </code>
              </pre>
            </div>
          </div>

          <div class="bg-purple-50 p-6 rounded-lg">
            <h3 class="text-xl font-semibold text-purple-800 mb-4">
              🔗 주요 클래스 및 패턴
            </h3>
            <p class="text-gray-700 leading-relaxed">
              Java 구현에서 사용되는 주요 클래스와 패턴을 설명합니다.
            </p>
            <ul class="text-gray-700 space-y-2">
              <li class="flex items-start">
                <span class="text-purple-600 mr-2">•</span>
                <strong>ChatController</strong>: SSE 스트리밍 채팅 엔드포인트
              </li>
              <li class="flex items-start">
                <span class="text-purple-600 mr-2">•</span>
                <strong>SseEmitter</strong>: 실시간 AI 응답 스트리밍
              </li>
              <li class="flex items-start">
                <span class="text-purple-600 mr-2">•</span>
                <strong>Redisson RLock</strong>: 모니터링 분산 락 구현
              </li>
              <li class="flex items-start">
                <span class="text-purple-600 mr-2">•</span>
                <strong>RedisTemplate</strong>: 신뢰성 큐 패턴 구현
              </li>
              <li class="flex items-start">
                <span class="text-purple-600 mr-2">•</span>
                <strong>WebClient</strong>: Python AI 서버 연동
              </li>
            </ul>
          </div>

          <div class="bg-orange-50 p-6 rounded-lg">
            <h3 class="text-xl font-semibold text-orange-800 mb-4">
              🔗 주의사항
            </h3>
            <ul class="text-gray-700 space-y-2">
              <li class="flex items-start">
                <span class="text-orange-600 mr-2">•</span>
                메모리 누수 방지: 스트리밍 연결 관리 및 리소스 해제
              </li>
              <li class="flex items-start">
                <span class="text-orange-600 mr-2">•</span>
                에러 처리: 비동기 흐름에서 발생하는 예외 처리
              </li>
              <li class="flex items-start">
                <span class="text-orange-600 mr-2">•</span>
                테스트: 모든 기능에 대한 단위 및 통합 테스트 수행
              </li>
            </ul>
          </div>
        </div>
      </section>

      <!-- React Integration Section -->
      <section id="react-integration" class="mb-16">
        <div class="bg-white rounded-lg shadow-lg p-8">
          <h2
            class="text-3xl font-bold text-gray-900 mb-6 border-b-2 border-blue-500 pb-3"
          >
            4. React 연동
          </h2>

          <div class="grid md:grid-cols-2 gap-8 mb-8">
            <div class="bg-blue-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-blue-800 mb-4">
                🔗 프론트엔드 구조
              </h3>
              <p class="text-gray-700 leading-relaxed">
                React 프론트엔드는 백엔드 API와 SSE 스트리밍을 연동하여 실시간
                AI 채팅 응답을 제공합니다.
              </p>
              <pre class="bg-gray-100 p-4 rounded-md text-sm">
                <code class="language-javascript">
                  // SSE 연결 (채팅 API 호출)
                  const sendChatMessage = async (message) => {
                      const response = await fetch('/api/chat', {
                          method: 'POST',
                          headers: {
                              'Content-Type': 'application/json',
                              'Accept': 'text/event-stream'
                          },
                          body: JSON.stringify({
                              message: message,
                              session_uuid: null
                          })
                      });

                      const reader = response.body.getReader();
                      const decoder = new TextDecoder();
                      
                      while (true) {
                          const { done, value } = await reader.read();
                          if (done) break;
                          
                          const chunk = decoder.decode(value);
                          const lines = chunk.split('\n');
                          
                          for (const line of lines) {
                              if (line.startsWith('data: ')) {
                                  const data = JSON.parse(line.slice(6));
                                  handleSSEEvent(data);
                              }
                          }
                      }
                  };

                  // SSE 이벤트 처리
                  const handleSSEEvent = (event) => {
                      if (event.type === "token") {
                          // AI 응답 토큰 처리
                      } else if (event.type === "finish") {
                          // 스트림 완료 처리
                      }
                  };
                </code>
              </pre>
            </div>

            <div class="bg-green-50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-green-800 mb-4">
                🔗 주요 기능 연동
              </h3>
              <p class="text-gray-700 leading-relaxed">
                프론트엔드에서 백엔드 API와 SSE 스트리밍을 통해 제공되는 주요
                기능을 연동하는 방법을 설명합니다.
              </p>
              <ul class="text-gray-700 space-y-2">
                <li class="flex items-start">
                  <span class="text-green-600 mr-2">•</span>
                  AI 채팅 (SSE 스트리밍)
                </li>
                <li class="flex items-start">
                  <span class="text-green-600 mr-2">•</span>
                  무역 뉴스 생성
                </li>
                <li class="flex items-start">
                  <span class="text-green-600 mr-2">•</span>
                  북마크 모니터링
                </li>
                <li class="flex items-start">
                  <span class="text-green-600 mr-2">•</span>
                  실시간 알림 처리
                </li>
              </ul>
            </div>
          </div>

          <div class="bg-purple-50 p-6 rounded-lg">
            <h3 class="text-xl font-semibold text-purple-800 mb-4">
              🔗 주의사항
            </h3>
            <ul class="text-gray-700 space-y-2">
              <li class="flex items-start">
                <span class="text-purple-600 mr-2">•</span>
                네트워크 오류 처리: SSE 연결 실패 시 재시도 전략
              </li>
              <li class="flex items-start">
                <span class="text-purple-600 mr-2">•</span>
                스트림 관리: 채팅 세션 상태와 토큰 처리
              </li>
              <li class="flex items-start">
                <span class="text-purple-600 mr-2">•</span>
                성능 최적화: 스트림 버퍼링 및 메모리 사용량 관리
              </li>
            </ul>
          </div>
        </div>
      </section>

      <!-- Java Implementation Examples Section -->
      <section id="implementation-examples" class="mb-16">
        <div class="bg-white rounded-lg shadow-lg p-8">
          <h2
            class="text-3xl font-bold text-gray-900 mb-6 border-b-2 border-blue-500 pb-3"
          >
            5. 실제 Java 구현 예시
          </h2>

          <!-- Chat Service Implementation -->
          <div class="mb-12">
            <h3
              class="text-2xl font-semibold text-gray-800 mb-6 bg-blue-50 p-4 rounded-lg"
            >
              💬 채팅 서비스 구현 (SSE 스트리밍)
            </h3>

            <div class="grid lg:grid-cols-2 gap-6">
              <div class="bg-gray-50 p-6 rounded-lg">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">
                  ChatController.java
                </h4>
                <pre
                  class="bg-code-bg text-code-text p-4 rounded-md text-sm overflow-x-auto"
                ><code>@RestController
@RequestMapping("/chat")
@RequiredArgsConstructor
@Slf4j
public class ChatController {

    private final ChatService chatService;

    @PostMapping(produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    @Operation(summary = "AI 채팅 스트리밍")
    public SseEmitter streamChat(
            @Valid @RequestBody ChatRequest request,
            @AuthenticationPrincipal UserDetails userDetails) {
        
        String userId = userDetails != null ? 
            userDetails.getUsername() : null;
        
        log.info("채팅 요청: userId={}, message={}", 
            userId, request.message());
        
        return chatService.streamChat(request, userId);
    }
}</code></pre>
              </div>

              <div class="bg-gray-50 p-6 rounded-lg">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">
                  ChatService.java (핵심 부분)
                </h4>
                <pre
                  class="bg-code-bg text-code-text p-4 rounded-md text-sm overflow-x-auto"
                ><code>@Service
@RequiredArgsConstructor
@Slf4j
public class ChatService {

    private final WebClient pythonAiWebClient;
    private final ChatSessionRepository sessionRepository;
    private final ObjectMapper objectMapper;

    public SseEmitter streamChat(ChatRequest request, String userId) {
        SseEmitter emitter = new SseEmitter(300000L);
        
        CompletableFuture.runAsync(() -> {
            try {
                // Python AI 서버로 SSE 스트림 요청 후 중계
                pythonAiWebClient.post()
                    .uri("/api/v1/chat")
                    .contentType(MediaType.APPLICATION_JSON)
                    .accept(MediaType.TEXT_EVENT_STREAM)
                    .bodyValue(request)
                    .retrieve()
                    .bodyToFlux(String.class)
                    .doOnNext(chunk -> {
                        try {
                            emitter.send(SseEmitter.event().data(chunk));
                        } catch (IOException e) {
                            log.error("SSE 전송 오류", e);
                        }
                    })
                    .doOnError(error -> {
                        log.error("Python AI 서버 오류", error);
                        emitter.completeWithError(error);
                    })
                    .doOnComplete(() -> {
                        log.info("스트림 완료");
                        emitter.complete();
                    })
                    .subscribe();
            } catch (Exception e) {
                log.error("채팅 처리 중 오류", e);
                emitter.completeWithError(e);
            }
        });
        
        return emitter;
    }
}</code></pre>
              </div>
            </div>
          </div>

          <!-- Monitoring Service Implementation -->
          <div class="mb-12">
            <h3
              class="text-2xl font-semibold text-gray-800 mb-6 bg-green-50 p-4 rounded-lg"
            >
              📊 모니터링 서비스 구현 (분산 락 + Redis 큐)
            </h3>

            <div class="grid lg:grid-cols-2 gap-6">
              <div class="bg-gray-50 p-6 rounded-lg">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">
                  MonitoringService.java
                </h4>
                <pre
                  class="bg-code-bg text-code-text p-4 rounded-md text-sm overflow-x-auto"
                ><code>@Service
@RequiredArgsConstructor
@Slf4j
public class MonitoringService {

    private final RedissonClient redissonClient;
    private final BookmarkRepository bookmarkRepository;
    private final RedisTemplate&lt;String, Object&gt; redisTemplate;

    public MonitoringResponse executeMonitoring() {
        RLock lock = redissonClient.getLock("monitoring-lock");
        
        try {
            boolean isLocked = lock.tryLock(10, TimeUnit.SECONDS);
            if (!isLocked) {
                return MonitoringResponse.builder()
                    .status("already_running")
                    .lockStatus("already_locked")
                    .build();
            }
            
            return performMonitoring();
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("모니터링 락 획득 중 인터럽트", e);
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}</code></pre>
              </div>

              <div class="bg-gray-50 p-6 rounded-lg">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">
                  NotificationSendingService.java
                </h4>
                <pre
                  class="bg-code-bg text-code-text p-4 rounded-md text-sm overflow-x-auto"
                ><code>@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationSendingService {

    private final RedisTemplate&lt;String, Object&gt; redisTemplate;
    private final EmailService emailService;
    
    // Python AI 서버 알림 소비 (신뢰성 큐 패턴)
    private void consumePythonNotifications(String type) {
        String queueKey = "daily_notification:queue:" + type;
        String processingKey = "daily_notification:processing_queue:" + type;
        
        while (running.get()) {
            try {
                // BLMOVE로 안전한 작업 이동
                String taskId = (String) redisTemplate.opsForList()
                    .rightPopAndLeftPush(queueKey, processingKey, 
                        Duration.ofSeconds(10));
                
                if (taskId != null) {
                    processPythonNotification(taskId, type, processingKey);
                }
            } catch (Exception e) {
                log.error("{} 알림 처리 중 오류", type, e);
            }
        }
    }
}</code></pre>
              </div>
            </div>
          </div>

          <!-- React Integration Example -->
          <div class="mb-12">
            <h3
              class="text-2xl font-semibold text-gray-800 mb-6 bg-purple-50 p-4 rounded-lg"
            >
              ⚛️ React 연동 구현 (SSE 클라이언트)
            </h3>

            <div class="grid lg:grid-cols-2 gap-6">
              <div class="bg-gray-50 p-6 rounded-lg">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">
                  ChatComponent.jsx
                </h4>
                <pre
                  class="bg-code-bg text-code-text p-4 rounded-md text-sm overflow-x-auto"
                ><code>import { useState, useEffect, useRef } from 'react';

function ChatComponent() {
    const [message, setMessage] = useState('');
    const [chatHistory, setChatHistory] = useState([]);
    const [isStreaming, setIsStreaming] = useState(false);
    const [currentSession, setCurrentSession] = useState(null);
    const [currentAIMessage, setCurrentAIMessage] = useState('');

    const handleSendMessage = async () => {
        if (!message.trim()) return;
        
        // 사용자 메시지 추가
        const userMessage = { type: 'user', content: message };
        setChatHistory(prev => [...prev, userMessage]);
        
        setIsStreaming(true);
        setCurrentAIMessage('');
        
        try {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'text/event-stream'
                },
                body: JSON.stringify({
                    message: message,
                    sessionUuid: currentSession,
                    userId: null // 비회원
                })
            });

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data.trim()) {
                            try {
                                const event = JSON.parse(data);
                                handleSSEEvent(event);
                            } catch (e) {
                                console.error('JSON 파싱 오류:', e);
                            }
                        }
                    }
                }
            }
        } catch (error) {
            console.error('채팅 오류:', error);
        } finally {
            setIsStreaming(false);
            setMessage('');
        }
    };

    const handleSSEEvent = (event) => {
        switch (event.type) {
            case 'session_id':
                setCurrentSession(event.data);
                console.log('새 세션 ID:', event.data);
                break;
            case 'token':
                setCurrentAIMessage(prev => prev + event.data);
                break;
            case 'finish':
                // 완성된 AI 메시지를 채팅 히스토리에 추가
                setChatHistory(prev => [...prev, {
                    type: 'ai',
                    content: currentAIMessage
                }]);
                setCurrentAIMessage('');
                console.log('스트림 완료');
                break;
            case 'error':
                console.error('AI 오류:', event.data);
                break;
        }
    };

    return (
        &lt;div className="chat-container"&gt;
            &lt;div className="chat-history"&gt;
                {chatHistory.map((msg, index) => (
                    &lt;div key={index} className={`message ${msg.type}`}&gt;
                        {msg.content}
                    &lt;/div&gt;
                ))}
                {/* 현재 스트리밍 중인 AI 메시지 표시 */}
                {isStreaming && currentAIMessage && (
                    &lt;div className="message ai streaming"&gt;
                        {currentAIMessage}
                        &lt;span className="cursor"&gt;▊&lt;/span&gt;
                    &lt;/div&gt;
                )}
            &lt;/div&gt;
            
            &lt;div className="chat-input"&gt;
                &lt;input
                    type="text"
                    value={message}
                    onChange={(e) => setMessage(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
                    disabled={isStreaming}
                    placeholder="메시지를 입력하세요..."
                /&gt;
                &lt;button 
                    onClick={handleSendMessage}
                    disabled={isStreaming}
                &gt;
                    {isStreaming ? '전송 중...' : '전송'}
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre>
              </div>

              <div class="bg-gray-50 p-6 rounded-lg">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">
                  API 클라이언트 설정
                </h4>
                <pre
                  class="bg-code-bg text-code-text p-4 rounded-md text-sm overflow-x-auto"
                ><code>// apiClient.js
import axios from 'axios';

const apiClient = axios.create({
    baseURL: process.env.REACT_APP_API_BASE_URL || 'http://localhost:8080',
    timeout: 30000,
    headers: {
        'Content-Type': 'application/json'
    }
});

// 요청 인터셉터
apiClient.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('authToken');
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => Promise.reject(error)
);

// 응답 인터셉터
apiClient.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 401) {
            // 인증 오류 처리
            localStorage.removeItem('authToken');
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);

export default apiClient;</code></pre>
              </div>
            </div>
          </div>

          <!-- Configuration Examples -->
          <div class="mb-12">
            <h3
              class="text-2xl font-semibold text-gray-800 mb-6 bg-orange-50 p-4 rounded-lg"
            >
              ⚙️ 설정 파일 예시
            </h3>

            <div class="grid lg:grid-cols-2 gap-6">
              <div class="bg-gray-50 p-6 rounded-lg">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">
                  application.yml
                </h4>
                <pre
                  class="bg-code-bg text-code-text p-4 rounded-md text-sm overflow-x-auto"
                ><code>spring:
  application:
    name: trade-ai-service
  
  datasource:
    url: jdbc:postgresql://localhost:5432/trade_ai
    username: ${DB_USERNAME:trade_user}
    password: ${DB_PASSWORD:trade_password}
    driver-class-name: org.postgresql.Driver
  
  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        show_sql: false
        format_sql: true
  
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0

server:
  port: 8080
  servlet:
    context-path: /

logging:
  level:
    com.hscoderadar: DEBUG
    org.springframework.web: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always

# Python AI 서버 연동 설정
python-ai:
  base-url: ${PYTHON_AI_BASE_URL:http://localhost:8000}
  timeout: 120s
  
# 모니터링 설정
monitoring:
  job:
    lock-key: monitoring:job:lock
    lock-timeout: 3600
  concurrent-requests-limit: 5
  rpm-limit: 60
  
# 알림 설정
notification:
  queue:
    key-prefix: daily_notification:queue:
  detail:
    key-prefix: daily_notification:detail:</code></pre>
              </div>

              <div class="bg-gray-50 p-6 rounded-lg">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">
                  RedisConfig.java
                </h4>
                <pre
                  class="bg-code-bg text-code-text p-4 rounded-md text-sm overflow-x-auto"
                ><code>@Configuration
@EnableRedisRepositories
@RequiredArgsConstructor
public class RedisConfig {

    @Value("${spring.redis.host}")
    private String redisHost;
    
    @Value("${spring.redis.port}")
    private int redisPort;

    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        return new LettuceConnectionFactory(
            new RedisStandaloneConfiguration(redisHost, redisPort));
    }

    @Bean
    @Qualifier("redisObjectTemplate")
    public RedisTemplate&lt;String, Object&gt; redisObjectTemplate(
            RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Object.class));
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Object.class));
        return template;
    }

    @Bean
    @Qualifier("queueRedisTemplate")
    public RedisTemplate&lt;String, Object&gt; queueRedisTemplate(
            RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new StringRedisSerializer());
        return template;
    }

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
            .setAddress("redis://" + redisHost + ":" + redisPort)
            .setConnectionMinimumIdleSize(2)
            .setConnectionPoolSize(8)
            .setRetryAttempts(3)
            .setRetryInterval(1500);
        return Redisson.create(config);
    }
}</code></pre>
              </div>
            </div>
          </div>

          <!-- Quality Assurance Checklist -->
          <div class="bg-gradient-to-r from-red-50 to-pink-50 p-8 rounded-lg">
            <h3 class="text-2xl font-semibold text-red-800 mb-6">
              🔍 품질 보증(QA) 체크리스트
            </h3>

            <div class="grid md:grid-cols-2 gap-8">
              <div>
                <h4 class="text-lg font-semibold text-red-700 mb-4">
                  필수 검증 항목
                </h4>
                <div class="space-y-3">
                  <label class="flex items-center space-x-3">
                    <input
                      type="checkbox"
                      class="form-checkbox h-5 w-5 text-red-600"
                    />
                    <span class="text-gray-700"
                      >논리적 무결성: Python AI 서버 연동 실패 시 적절한 오류
                      처리</span
                    >
                  </label>
                  <label class="flex items-center space-x-3">
                    <input
                      type="checkbox"
                      class="form-checkbox h-5 w-5 text-red-600"
                    />
                    <span class="text-gray-700"
                      >API 명세 준수: ChatRequest, MonitoringResponse 모델이
                      Python API 명세를 정확히 반영</span
                    >
                  </label>
                  <label class="flex items-center space-x-3">
                    <input
                      type="checkbox"
                      class="form-checkbox h-5 w-5 text-red-600"
                    />
                    <span class="text-gray-700"
                      >스트리밍 처리: SseEmitter가 모든 시나리오에서 정상 종료
                      및 리소스 해제</span
                    >
                  </label>
                  <label class="flex items-center space-x-3">
                    <input
                      type="checkbox"
                      class="form-checkbox h-5 w-5 text-red-600"
                    />
                    <span class="text-gray-700"
                      >신뢰성 큐: 모니터링 분산 락이 예외 상황에서도 100%
                      해제</span
                    >
                  </label>
                </div>
              </div>

              <div>
                <h4 class="text-lg font-semibold text-red-700 mb-4">
                  성능 및 보안
                </h4>
                <div class="space-y-3">
                  <label class="flex items-center space-x-3">
                    <input
                      type="checkbox"
                      class="form-checkbox h-5 w-5 text-red-600"
                    />
                    <span class="text-gray-700"
                      >성능: 모니터링 병렬 처리 시 적절한 Semaphore 크기
                      설정</span
                    >
                  </label>
                  <label class="flex items-center space-x-3">
                    <input
                      type="checkbox"
                      class="form-checkbox h-5 w-5 text-red-600"
                    />
                    <span class="text-gray-700"
                      >N+1 쿼리: 북마크 조회 시 fetch join 최적화 확인</span
                    >
                  </label>
                  <label class="flex items-center space-x-3">
                    <input
                      type="checkbox"
                      class="form-checkbox h-5 w-5 text-red-600"
                    />
                    <span class="text-gray-700"
                      >구성 관리: Redis 연결 정보 및 Python AI 서버 URL 환경
                      변수 관리</span
                    >
                  </label>
                  <label class="flex items-center space-x-3">
                    <input
                      type="checkbox"
                      class="form-checkbox h-5 w-5 text-red-600"
                    />
                    <span class="text-gray-700"
                      >테스트: 채팅 스트리밍, 모니터링, 알림 큐 처리에 대한
                      단위/통합 테스트</span
                    >
                  </label>
                </div>
              </div>
            </div>

            <div class="mt-8 p-4 bg-white rounded-lg border-l-4 border-red-500">
              <p class="text-red-800 font-semibold">
                <span class="text-red-600">⚠️ 선언:</span>
                상기 체크리스트를 모두 통과했으며, Context7 검증을 거친 이 중계
                아키텍처 가이드가 최고의 품질을 가짐을 명예를 걸고 보증합니다.
              </p>
            </div>
          </div>
        </div>
      </section>
    </main>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white py-8 mt-16">
      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
        <p class="text-gray-300">© 2025 Trade AI Service Integration Guide</p>
        <p class="text-gray-400 text-sm mt-2">
          Context7 검증 완료 · Spring Boot 3.x 호환
        </p>
      </div>
    </footer>

    <!-- JavaScript for mobile menu -->
    <script>
      document
        .getElementById("mobile-menu-btn")
        .addEventListener("click", function () {
          const menu = document.getElementById("nav-menu");
          menu.classList.toggle("hidden");
        });

      // Smooth scrolling for navigation links
      document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
        anchor.addEventListener("click", function (e) {
          e.preventDefault();
          const target = document.querySelector(this.getAttribute("href"));
          if (target) {
            target.scrollIntoView({
              behavior: "smooth",
              block: "start",
            });
          }
        });
      });
    </script>
  </body>
</html>
