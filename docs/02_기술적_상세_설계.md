# ê¸°ìˆ ì  ìƒì„¸ ì„¤ê³„ - HSCode ìƒì„¸í˜ì´ì§€ ì •ë³´ ì¤€ë¹„

## ğŸ“‹ ê°œìš”
Context7ì„ í™œìš©í•œ ì‘ì—… B (HSCode ìƒì„¸í˜ì´ì§€ ì •ë³´ ì¤€ë¹„)ì˜ ìƒì„¸ ê¸°ìˆ  ì„¤ê³„ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.

## ğŸ—ï¸ ì „ì²´ ì•„í‚¤í…ì²˜

### ì‹œìŠ¤í…œ êµ¬ì¡°ë„
```mermaid
graph TD
    A[ì‚¬ìš©ì ìš”ì²­] --> B[Chat Endpoint]
    B --> C[ë³‘ë ¬ ì²˜ë¦¬ ë§¤ë‹ˆì €]
    C --> D[ì‘ì—… A: AI ì‘ë‹µ]
    C --> E[ì‘ì—… B: ìƒì„¸í˜ì´ì§€ ì •ë³´]
    C --> F[ì‘ì—… C: ëŒ€í™” ì €ì¥]
    
    E --> G[Context7 ë˜í¼]
    G --> H[Context7 MCP]
    H --> I[HSCode ë¶„ì„]
    I --> J[ìƒì„¸í˜ì´ì§€ ë²„íŠ¼ ìƒì„±]
    J --> K[SSE ì´ë²¤íŠ¸ ë°œì†¡]
    
    E --> L[PostgreSQL ì €ì¥]
```

### í•µì‹¬ ì»´í¬ë„ŒíŠ¸

#### 1. **Context7AsyncWrapper** 
- Context7 MCP ë„êµ¬ì˜ ë¹„ë™ê¸° ë˜í¼
- ë™ê¸° í˜¸ì¶œì„ ë¹„ë™ê¸°ë¡œ ë³€í™˜
- ì—ëŸ¬ í•¸ë“¤ë§ ë° ì¬ì‹œë„ ë¡œì§

#### 2. **DetailPageService**
- HSCode ë¶„ì„ ë° ìƒì„¸í˜ì´ì§€ ì •ë³´ ìƒì„±
- Context7 ì‘ë‹µ ë°ì´í„° ê²€ì¦ ë° ë³€í™˜
- ë²„íŠ¼ ìš°ì„ ìˆœìœ„ ê²°ì •

#### 3. **ParallelTaskManager**
- 3ë‹¨ê³„ ë³‘ë ¬ ì²˜ë¦¬ ì¡°ìœ¨
- íƒœìŠ¤í¬ ìƒíƒœ ê´€ë¦¬ ë° ë™ê¸°í™”
- ë¦¬ì†ŒìŠ¤ ìµœì í™”

#### 4. **SSEEventGenerator**
- ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ìƒì„± ë° ì „ì†¡
- ì´ë²¤íŠ¸ ìˆœì„œ ë³´ì¥
- í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§

## ğŸ”§ ì£¼ìš” ì»´í¬ë„ŒíŠ¸ ìƒì„¸ ì„¤ê³„

### 1. Context7AsyncWrapper

```python
from typing import Dict, Any, Optional
import asyncio
import functools
from contextlib import asynccontextmanager

class Context7AsyncWrapper:
    """Context7 MCP ë„êµ¬ì˜ ë¹„ë™ê¸° ë˜í¼"""
    
    def __init__(self, max_workers: int = 3, timeout: int = 30):
        self.max_workers = max_workers
        self.timeout = timeout
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def resolve_library_id_async(
        self, 
        library_name: str
    ) -> Dict[str, Any]:
        """ë¼ì´ë¸ŒëŸ¬ë¦¬ ID ë¹„ë™ê¸° ì¡°íšŒ"""
        return await self._execute_with_timeout(
            mcp_context7_resolve_library_id,
            libraryName=library_name
        )
    
    async def get_library_docs_async(
        self,
        library_id: str,
        topic: Optional[str] = None,
        tokens: int = 3000
    ) -> Dict[str, Any]:
        """ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ ë¹„ë™ê¸° ì¡°íšŒ"""
        return await self._execute_with_timeout(
            mcp_context7_get_library_docs,
            context7CompatibleLibraryID=library_id,
            topic=topic,
            tokens=tokens
        )
    
    async def _execute_with_timeout(self, func, **kwargs):
        """íƒ€ì„ì•„ì›ƒê³¼ í•¨ê»˜ Context7 í•¨ìˆ˜ ì‹¤í–‰"""
        loop = asyncio.get_event_loop()
        try:
            result = await asyncio.wait_for(
                loop.run_in_executor(
                    self.executor,
                    functools.partial(func, **kwargs)
                ),
                timeout=self.timeout
            )
            return result
        except asyncio.TimeoutError:
            raise Context7TimeoutError(f"Context7 í˜¸ì¶œ íƒ€ì„ì•„ì›ƒ: {func.__name__}")
        except Exception as e:
            raise Context7ApiError(f"Context7 API ì˜¤ë¥˜: {str(e)}")
```

### 2. DetailPageService

```python
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, ValidationError
import logging

class DetailPageInfo(BaseModel):
    """ìƒì„¸í˜ì´ì§€ ì •ë³´ ëª¨ë¸"""
    hscode: Optional[str] = None
    detected_intent: str
    detail_buttons: List[DetailButton]
    processing_time_ms: int
    confidence_score: float
    analysis_source: str  # "context7" | "fallback" | "cache"
    
class DetailPageService:
    """ìƒì„¸í˜ì´ì§€ ì •ë³´ ì¤€ë¹„ ì„œë¹„ìŠ¤"""
    
    def __init__(self):
        self.context7_wrapper = Context7AsyncWrapper()
        self.cache = DetailPageCache()
        self.fallback_analyzer = FallbackHSCodeAnalyzer()
    
    async def prepare_detail_page_info(
        self,
        message: str,
        session_uuid: str,
        user_id: Optional[int] = None
    ) -> DetailPageInfo:
        """ìƒì„¸í˜ì´ì§€ ì •ë³´ ì¤€ë¹„ - ë‹¤ë‹¨ê³„ í´ë°± ì „ëµ"""
        start_time = time.time()
        
        try:
            # 1ë‹¨ê³„: ìºì‹œ í™•ì¸
            cached_info = await self.cache.get(message)
            if cached_info:
                return cached_info
            
            # 2ë‹¨ê³„: Context7ì„ í†µí•œ ë¶„ì„
            try:
                context7_info = await self._analyze_with_context7(message)
                if context7_info.confidence_score >= 0.7:
                    await self.cache.set(message, context7_info)
                    return context7_info
            except (Context7TimeoutError, Context7ApiError) as e:
                logging.warning(f"Context7 ë¶„ì„ ì‹¤íŒ¨, í´ë°± ì‚¬ìš©: {e}")
            
            # 3ë‹¨ê³„: í´ë°± ë¶„ì„ê¸° ì‚¬ìš©
            fallback_info = await self.fallback_analyzer.analyze(message)
            return fallback_info
            
        finally:
            processing_time = int((time.time() - start_time) * 1000)
            # ë©”íŠ¸ë¦­ ê¸°ë¡
            self._record_metrics(processing_time, message)
    
    async def _analyze_with_context7(self, message: str) -> DetailPageInfo:
        """Context7ì„ ì‚¬ìš©í•œ HSCode ë¶„ì„"""
        
        # HSCode ê´€ë ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¡°íšŒ
        fastapi_id = await self.context7_wrapper.resolve_library_id_async("fastapi")
        pydantic_id = await self.context7_wrapper.resolve_library_id_async("pydantic")
        
        # ê´€ë ¨ ë¬¸ì„œ ì¡°íšŒ
        fastapi_docs = await self.context7_wrapper.get_library_docs_async(
            "/tiangolo/fastapi",
            topic="background tasks streaming response"
        )
        
        # HSCode íŒ¨í„´ ì¶”ì¶œ ë° ë¶„ì„
        hscode_patterns = self._extract_hscode_patterns(message)
        confidence = self._calculate_confidence(hscode_patterns, fastapi_docs)
        
        # ìƒì„¸í˜ì´ì§€ ë²„íŠ¼ ìƒì„±
        detail_buttons = self._generate_detail_buttons(hscode_patterns)
        
        return DetailPageInfo(
            hscode=hscode_patterns[0] if hscode_patterns else None,
            detected_intent="hscode_search",
            detail_buttons=detail_buttons,
            processing_time_ms=0,  # ë‚˜ì¤‘ì— ì„¤ì •
            confidence_score=confidence,
            analysis_source="context7"
        )
```

### 3. ParallelTaskManager

```python
import asyncio
from typing import NamedTuple, AsyncGenerator
from dataclasses import dataclass

@dataclass
class ParallelTaskResults:
    """ë³‘ë ¬ ì‘ì—… ê²°ê³¼"""
    ai_response_stream: AsyncGenerator[str, None]
    detail_page_info: Optional[DetailPageInfo]
    chat_saved: bool
    processing_times: Dict[str, int]

class ParallelTaskManager:
    """3ë‹¨ê³„ ë³‘ë ¬ ì²˜ë¦¬ ë§¤ë‹ˆì €"""
    
    def __init__(self):
        self.detail_page_service = DetailPageService()
        self.sse_generator = SSEEventGenerator()
    
    async def execute_parallel_tasks(
        self,
        chat_request: ChatRequest,
        db: AsyncSession,
        background_tasks: BackgroundTasks
    ) -> AsyncGenerator[str, None]:
        """3ë‹¨ê³„ ë³‘ë ¬ ì²˜ë¦¬ ì‹¤í–‰"""
        
        # ì¦‰ì‹œ ë³‘ë ¬ ì²˜ë¦¬ ì‹œì‘ ì´ë²¤íŠ¸ ì „ì†¡
        yield self.sse_generator.generate_thinking_event(
            "parallel_processing_start",
            "3ë‹¨ê³„ ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤",
            15
        )
        
        # 3ê°œ ì‘ì—…ì„ ë™ì‹œì— ì‹œì‘
        task_a = asyncio.create_task(
            self._execute_ai_response(chat_request, db)
        )
        task_b = asyncio.create_task(
            self._execute_detail_page_preparation(chat_request)
        )
        task_c = asyncio.create_task(
            self._execute_chat_saving(chat_request, db)
        )
        
        # ìƒì„¸í˜ì´ì§€ ë²„íŠ¼ ì¤€ë¹„ ì‹œì‘ ì´ë²¤íŠ¸
        yield self.sse_generator.generate_detail_buttons_start_event()
        
        # ê° ì‘ì—… ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦¬ë©° ê²°ê³¼ ì²˜ë¦¬
        async for event in self._handle_task_completion(task_a, task_b, task_c):
            yield event
    
    async def _execute_detail_page_preparation(
        self, 
        chat_request: ChatRequest
    ) -> DetailPageInfo:
        """ì‘ì—… B: ìƒì„¸í˜ì´ì§€ ì •ë³´ ì¤€ë¹„"""
        try:
            detail_info = await self.detail_page_service.prepare_detail_page_info(
                chat_request.message,
                chat_request.session_uuid,
                chat_request.user_id
            )
            return detail_info
        except Exception as e:
            logging.error(f"ìƒì„¸í˜ì´ì§€ ì •ë³´ ì¤€ë¹„ ì‹¤íŒ¨: {e}")
            # í´ë°± ì •ë³´ ë°˜í™˜
            return self._create_fallback_detail_info()
    
    async def _handle_task_completion(self, task_a, task_b, task_c):
        """ì‘ì—… ì™„ë£Œ ì²˜ë¦¬ ë° ì´ë²¤íŠ¸ ìƒì„±"""
        detail_info = None
        
        # ì‘ì—… B ì™„ë£Œ ëŒ€ê¸° (ìƒì„¸í˜ì´ì§€ ì •ë³´)
        try:
            detail_info = await asyncio.wait_for(task_b, timeout=10.0)
            
            # ìƒì„¸í˜ì´ì§€ ë²„íŠ¼ ì¤€ë¹„ ì™„ë£Œ ì´ë²¤íŠ¸ë“¤ ìƒì„±
            async for event in self.sse_generator.generate_detail_button_events(detail_info):
                yield event
                
        except asyncio.TimeoutError:
            logging.warning("ìƒì„¸í˜ì´ì§€ ì •ë³´ ì¤€ë¹„ íƒ€ì„ì•„ì›ƒ")
            yield self.sse_generator.generate_detail_buttons_timeout_event()
        
        # ì‘ì—… A ì™„ë£Œ ëŒ€ê¸° ë° ìŠ¤íŠ¸ë¦¬ë° (AI ì‘ë‹µ)
        ai_stream = await task_a
        async for chunk in ai_stream:
            yield chunk
        
        # ì‘ì—… C ì™„ë£Œ í™•ì¸ (ì±„íŒ… ì €ì¥)
        try:
            await asyncio.wait_for(task_c, timeout=5.0)
        except asyncio.TimeoutError:
            logging.warning("ì±„íŒ… ì €ì¥ íƒ€ì„ì•„ì›ƒ")
```

### 4. SSEEventGenerator

```python
import json
from datetime import datetime
from typing import Dict, Any, AsyncGenerator

class SSEEventGenerator:
    """SSE ì´ë²¤íŠ¸ ìƒì„±ê¸°"""
    
    def generate_thinking_event(
        self, 
        stage: str, 
        content: str, 
        progress: int
    ) -> str:
        """thinking ë‹¨ê³„ ì´ë²¤íŠ¸ ìƒì„±"""
        data = {
            "stage": stage,
            "content": content,
            "progress": progress,
            "timestamp": datetime.utcnow().isoformat() + "Z"
        }
        return f"event: thinking\ndata: {json.dumps(data, ensure_ascii=False)}\n\n"
    
    def generate_detail_buttons_start_event(self) -> str:
        """ìƒì„¸í˜ì´ì§€ ë²„íŠ¼ ì¤€ë¹„ ì‹œì‘ ì´ë²¤íŠ¸"""
        data = {
            "type": "start",
            "buttonsCount": 3,
            "timestamp": datetime.utcnow().isoformat() + "Z"
        }
        return f"event: detail_page_buttons_start\ndata: {json.dumps(data)}\n\n"
    
    async def generate_detail_button_events(
        self, 
        detail_info: DetailPageInfo
    ) -> AsyncGenerator[str, None]:
        """ìƒì„¸í˜ì´ì§€ ë²„íŠ¼ ì¤€ë¹„ ì™„ë£Œ ì´ë²¤íŠ¸ë“¤ ìƒì„±"""
        
        for i, button in enumerate(detail_info.detail_buttons):
            button_data = {
                "type": "button",
                "buttonType": button.type,
                "priority": i + 1,
                "url": button.url,
                "title": button.label,
                "description": f"{button.type} ê´€ë ¨ ì •ë³´",
                "isReady": True,
                "metadata": {
                    "hscode": detail_info.hscode,
                    "confidence": detail_info.confidence_score,
                    "source": detail_info.analysis_source
                }
            }
            
            yield f"event: detail_page_button_ready\ndata: {json.dumps(button_data, ensure_ascii=False)}\n\n"
            
            # ë²„íŠ¼ ê°„ ê°„ê²© (UX ê°œì„ )
            await asyncio.sleep(0.1)
        
        # ëª¨ë“  ë²„íŠ¼ ì¤€ë¹„ ì™„ë£Œ
        complete_data = {
            "type": "complete",
            "totalPreparationTime": detail_info.processing_time_ms
        }
        yield f"event: detail_page_buttons_complete\ndata: {json.dumps(complete_data)}\n\n"
```

## ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

### í™•ì¥ëœ chat_messages ìŠ¤í‚¤ë§ˆ
```sql
-- ê¸°ì¡´ ìŠ¤í‚¤ë§ˆì— ì¶”ê°€ë  í•„ë“œë“¤
ALTER TABLE chat_messages ADD COLUMN IF NOT EXISTS 
    context7_analysis jsonb,           -- Context7 ë¶„ì„ ê²°ê³¼
    detail_page_processing_time int,   -- ìƒì„¸í˜ì´ì§€ ì •ë³´ ì¤€ë¹„ ì‹œê°„
    parallel_task_metrics jsonb;       -- ë³‘ë ¬ ì²˜ë¦¬ ë©”íŠ¸ë¦­
```

### JSON ìŠ¤í‚¤ë§ˆ ì˜ˆì‹œ
```json
{
  "hscode_analysis": {
    "detected_hscode": "8517.12.00",
    "confidence": 0.95,
    "analysis_source": "context7",
    "processing_time_ms": 1500,
    "detail_buttons": [
      {
        "type": "HS_CODE",
        "url": "/detail/hscode/8517.12.00",
        "priority": 1
      }
    ]
  },
  "context7_analysis": {
    "library_queries": ["fastapi", "pydantic"],
    "docs_retrieved": 2,
    "total_tokens": 3000,
    "api_calls": 3,
    "success_rate": 1.0
  },
  "parallel_task_metrics": {
    "task_a_duration": 2500,
    "task_b_duration": 1500,
    "task_c_duration": 800,
    "total_duration": 2500,
    "efficiency_ratio": 0.6
  }
}
```

## ğŸš€ ì„±ëŠ¥ ìµœì í™” ì „ëµ

### 1. **ìºì‹± ì „ëµ**
- Context7 ì‘ë‹µ ê²°ê³¼ Redis ìºì‹± (TTL: 1ì‹œê°„)
- HSCode íŒ¨í„´ë³„ ê²°ê³¼ ìºì‹±
- ì‚¬ìš©ìë³„ ìµœê·¼ ì¿¼ë¦¬ ìºì‹±

### 2. **ë¦¬ì†ŒìŠ¤ ê´€ë¦¬**
- Context7 API í˜¸ì¶œ í’€ ê´€ë¦¬ (ìµœëŒ€ ë™ì‹œ í˜¸ì¶œ ì œí•œ)
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
- ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ í í¬ê¸° ì œí•œ

### 3. **ì—ëŸ¬ ë³µêµ¬**
- Context7 API ì¥ì•  ì‹œ í´ë°± ì‹œìŠ¤í…œ
- ë‹¨ê³„ë³„ íƒ€ì„ì•„ì›ƒ ì„¤ì •
- ë¶€ë¶„ ì‹¤íŒ¨ ì‹œ ìš°ì•„í•œ ì„±ëŠ¥ ì €í•˜

## ğŸ“Š ë‹¤ìŒ ë‹¨ê³„

1. **JSON ì‘ë‹µ êµ¬ì¡° ìƒì„¸ ì„¤ê³„** (3ë‹¨ê³„ ë¬¸ì„œ)
2. **êµ¬í˜„ ì¼ì • ë° ë§ˆì¼ìŠ¤í†¤** (4ë‹¨ê³„ ë¬¸ì„œ)
3. **í…ŒìŠ¤íŠ¸ ì „ëµ ë° ê²€ì¦ ë°©ë²•** (5ë‹¨ê³„ ë¬¸ì„œ) 