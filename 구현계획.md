네, 알겠습니다. 아키텍처의 핵심을 뒤바꾸는 매우 중요한 결정사항입니다. 정리하자면,

1.  **뉴스 수집 방식 변경:** 전통적인 크롤링이 아닌, **Claude의 웹 검색 및 추론(Thinking) 기능**을 활용하여 뉴스를 생성합니다.
2.  **작업 트리거 주체 변경:** Python 서버는 자체 스케줄러를 갖지 않습니다. 모든 주기적인 작업(뉴스 생성, 북마크 모니터링)의 **실행 트리거는 Spring Boot 서버의 스케줄러**가 담당하며, Python 서버의 특정 엔드포인트를 호출하는 방식으로 동작합니다.

이 변경은 Python 서버를 '스스로 일하는 에이전트'에서, 외부 요청에만 반응하는 **순수 온디맨드(On-Demand) AI 서비스 제공자**로 역할을 명확히 합니다. 이는 각 서버의 책임을 극도로 단순화하고 결합도를 낮추는, 매우 성숙하고 안정적인 마이크로서비스 아키텍처 설계입니다.

이러한 최종 결정사항을 완벽하게 반영하여, 이전에 제안했던 문서를 다시 한번 개선한 **"최종 확정: 온디맨드 AI 서비스 허브 구현 전략서"**를 제공해 드리겠습니다.

---

### **최종 확정: 온디맨드 AI 서비스 허브 구현 전략서 (v6.3)**

**문서 목표:** 플랫폼의 Python 서버를 **Spring Boot의 요청에 따라** 실시간 채팅, 지능형 뉴스 생성, 북마크 모니터링 등 모든 AI 및 데이터 처리 기능을 **온디맨드로 수행하는** 서비스 허브로 구축하기 위한 최종 아키텍처와 구현 계획을 제시합니다.

#### **1. 최종 아키텍처 및 데이터 흐름 (v6.3 확정)**

Spring Boot가 모든 작업의 시작점이 되는, 제어 흐름이 명확한 최종 아키텍처입니다.

```
      [React Client]
           │
           │ 1. API 요청 (e.g., /api/chat)
           ▼
┌───────────────────────────────────────────────────────────┐
│                      [Spring Boot Server]                   │
│                                                           │
│ ┌──────────────────┐  ┌─────────────────────────────────┐ │
│ │  [API Gateway]   │  │ [스케줄러 (@Scheduled)]           │ │
│ │ - JWT 인증, 라우팅 │  │ - 매시간: 뉴스 생성 요청 발송     │ │
│ │ - Python으로 프록시 │  │ - 매일: 모니터링 요청 발송      │ │
│ └────────┬─────────┘  └───────────────┬───────────────┘ │
│          │ 2a. 실시간 요청 전달       │ 2b. 스케줄링된 작업 요청 전달 │
└──────────┼──────────────────────────┼────────────────────┘
           │                          │
           │ 3. FastAPI 엔드포인트 호출 ( /chat, /generate-news, /run-monitoring )
           ▼
┌───────────────────────────────────────────────────────────┐
│              [Python FastAPI Server (On-Demand)]          │
│                                                           │
│  - 요청에 따라 해당 AI 기능 및 DB 작업 수행:                 │
│    - (/chat) 회원/비회원 채팅, 세션 관리, RAG, SSE 스트리밍 │
│    - (/generate-news) Claude 웹 검색 통한 뉴스 생성 및 DB 저장 │
│    - (/run-monitoring) 북마크 관련 정보 분석 및 피드 저장     │
│                                                           │
│  - 자체 스케줄러 없음. 외부 요청에만 응답.                     │
└───────────────────────────────────────────────────────────┘
           │
           │ 4. API 응답 (SSE, JSON 등)
           ▼
┌──────────┴────────────────────────────────────────────────┐
│                      [Spring Boot Server]                   │
│                                                           │
│  - 5a. (채팅) SSE 스트림을 Client로 중계                   │
│  - 5b. (백그라운드) 작업 성공/실패 로깅                      │
│  - 5c. (알림) update_feeds 테이블 확인 후 SMS/이메일 발송  │
└───────────────────────────────────────────────────────────┘
           │
           │ 6. UI 렌더링 / 알림 수신
           ▼
      [React Client]
```

**최종 확정된 책임 원칙:**
*   **Python (FastAPI):** 플랫폼의 모든 인텔리전스를 제공하는 **고성능 AI 연산 유닛**. 외부의 명확한 '명령'(API 요청)이 있을 때만 동작하며, 그 결과를 DB에 기록하거나 요청자에게 반환합니다.
*   **Spring Boot:** 전체 시스템의 흐름을 지휘하는 **컨트롤 타워(Control Tower)**. 사용자 인증, 요청 중계, 주기적인 작업 지시, 최종 사용자 알림까지 모든 오케스트레이션을 담당합니다.

---

#### **2. Python 서버 기술 스택 및 설정 (최종)**

자체 스케줄러가 제거되어 기술 스택이 더 간결하고 명확해집니다.

*   **프레임워크:** `FastAPI`
*   **SSE 구현:** `sse-starlette`
*   **AI/LLM:** `langchain`, `langchain-anthropic`, `langchain-openai`
*   **DB:** `SQLAlchemy`, `psycopg-binary`, `pgvector`
*   **임베딩:** `voyageai`
*   **웹 검색 도구:** `Anthropic 네이티브 검색` (모델 내장 기능)
*   **HTTP 클라이언트:** `httpx`

**`pyproject.toml` (제거 항목 반영)**
```toml
[project]
name = "trade-ai-server"
version = "0.1.0"
dependencies = [
    "fastapi",
    "uvicorn[standard]",
    "SQLAlchemy",
    "psycopg-binary",
    "pgvector",
    "sse-starlette",
    "langchain",
    "langchain-anthropic",
    "langchain-openai",
    "langchain-community",
    "python-dotenv",
    "httpx",
]
```

---

#### **3. 핵심 기능 구현 계획 (최종)**

Python 서버는 아래와 같이 3개의 핵심 엔드포인트를 제공합니다.

**3.1. 실시간 채팅 API (`POST /chat`)**

*   **역할:** 사용자와의 실시간 상호작용.
*   **구현:** 이전 제안서의 내용과 동일합니다. Spring Boot로부터 `userId`를 받아 회원/비회원 로직을 처리하고, RAG 및 SSE 스트리밍을 수행합니다.
*   **관련 데이터베이스 테이블:**
    <details>
    <summary><code>chat_sessions</code> 테이블 스키마 보기</summary>

    ```sql
    -- 회원 전용 채팅 세션 부모 테이블 (파티션 테이블)
    CREATE TABLE chat_sessions (
        session_uuid UUID NOT NULL DEFAULT gen_random_uuid(),
        user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        session_title VARCHAR(255) NULL,
        message_count INTEGER NOT NULL DEFAULT 0,

        -- 💡 [v6.2 수정] 기본 키(PK)에 파티셔닝 키(created_at)를 반드시 포함해야 합니다.
        -- 이는 PostgreSQL의 파티션 테이블 UNIQUE 제약 조건(PK 포함)의 필수 요구사항이며,
        -- 이를 통해 파티션 프루닝(Partition Pruning)이 효율적으로 동작합니다.
        PRIMARY KEY (session_uuid, created_at)

    ) PARTITION BY RANGE (created_at);

    -- 주석 추가
    COMMENT ON TABLE chat_sessions IS '회원 전용 채팅 세션 - pg_partman 기반 자동 파티셔닝 및 주기별 정리';
    COMMENT ON COLUMN chat_sessions.user_id IS '회원 전용: 비회원 접근 불가 (NOT NULL)';
    COMMENT ON COLUMN chat_sessions.session_title IS '첫 번째 질문 요약 (최대 50자)';
    COMMENT ON COLUMN chat_sessions.message_count IS '세션 내 메시지 수';
    COMMENT ON COLUMN chat_sessions.created_at IS '세션 생성 시간, 파티셔닝 키';
    ```
    </details>
    <details>
    <summary><code>chat_messages</code> 테이블 스키마 보기</summary>

    ```sql
    -- 회원 전용 채팅 메시지 부모 테이블 (파티션 테이블)
    CREATE TABLE chat_messages (
        message_id BIGINT GENERATED ALWAYS AS IDENTITY,

        -- 💡 [v6.2 수정] chat_sessions의 PK가 (session_uuid, created_at)으로 변경됨에 따라,
        -- 이를 참조하기 위한 session_created_at 컬럼을 추가하고 복합 외래 키(Composite FK)로 변경합니다.
        session_uuid UUID NOT NULL,
        session_created_at TIMESTAMP NOT NULL, -- FK 관계를 위한 부모 테이블의 파티셔닝 키

        message_type VARCHAR(20) NOT NULL CHECK (message_type IN ('USER', 'AI')),
        content TEXT NOT NULL,
        ai_model VARCHAR(100) NULL,
        thinking_process TEXT NULL,
        hscode_analysis JSONB NULL,
        sse_bookmark_data JSONB NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

        -- 💡 [v6.2 유지] 파티션 테이블의 PK에는 파티션 키가 포함되어야 한다는 규칙을 준수합니다.
        PRIMARY KEY (message_id, created_at),

        -- 💡 [v6.2 수정] 복합 외래 키(Composite Foreign Key) 설정으로 데이터 무결성 보장
        FOREIGN KEY (session_uuid, session_created_at)
            REFERENCES chat_sessions(session_uuid, created_at)
            ON DELETE CASCADE

    ) PARTITION BY RANGE (created_at);

    -- 주석 추가
    COMMENT ON TABLE chat_messages IS '회원 전용 채팅 메시지 - pg_partman 기반 자동 파티셔닝 및 주기별 정리';
    COMMENT ON COLUMN chat_messages.session_created_at IS '부모 테이블(chat_sessions)의 PK이자 파티션 키인 created_at을 참조';
    COMMENT ON COLUMN chat_messages.message_type IS '메시지 타입: USER 또는 AI';
    COMMENT ON COLUMN chat_messages.content IS '메시지 내용';
    COMMENT ON COLUMN chat_messages.ai_model IS '사용된 AI 모델 (AI 메시지만)';
    COMMENT ON COLUMN chat_messages.thinking_process IS 'AI 사고과정 (AI 메시지만)';
    COMMENT ON COLUMN chat_messages.hscode_analysis IS 'HSCode 분석 결과 (AI 메시지만)';
    COMMENT ON COLUMN chat_messages.sse_bookmark_data IS 'SSE로 동적 생성된 북마크 관련 데이터';
    ```
    </details>

**3.2. 온디맨드 뉴스 생성 API (`POST /news`)**

*   **역할:** Spring Boot의 스케줄링 요청에 따라 최신 무역 뉴스를 생성하고 DB에 저장.
*   **구현 방안:**
    1.  **FastAPI 엔드포인트 생성:** `POST /news`
    2.  **Anthropic 네이티브 검색 활용:** `ChatAnthropic` 모델에 네이티브 웹 검색 도구를 바인딩하여, 외부 도구 없이 Claude가 직접 웹을 검색하도록 합니다. `Tavily`와 같은 별도 라이브러리 및 API 키가 필요 없어 아키텍처가 단순해지고 안정성이 향상됩니다.
    3.  **정교한 프롬프트 설계:**
        ```prompt
        "You are an expert trade analyst for a Korean company. Your task is to find the top 3-5 most critical and recent (within the last 24 hours) global trade news items that could impact South Korean import/export businesses. For each news item, provide a concise title, a summary (in Korean, 2-3 sentences), the source URL, and publication date. Focus on tariffs, regulations, supply chain disruptions, and trade agreements. Present the result in a structured JSON format."
        ```
    4.  **결과 파싱 및 DB 저장:** Claude가 반환한 구조화된 JSON 결과를 파싱하여 `news` 테이블에 저장합니다.
*   **관련 데이터베이스 테이블:**
    <details>
    <summary><code>news</code> 테이블 스키마 보기</summary>

    ```sql
    CREATE TABLE news (
        id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
        title VARCHAR(500) NOT NULL,
        source_url VARCHAR(1000) NOT NULL,
        source_name VARCHAR(200) NOT NULL,
        published_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    COMMENT ON TABLE news IS '무역 뉴스 정보';

    CREATE INDEX idx_news_published_at ON news(published_at DESC);
    CREATE INDEX idx_news_created_at ON news(created_at DESC);
    ```
    </details>

```python
# app/api/v1/endpoints/news.py
@router.post("/news")
async def generate_trade_news():
    """Spring Boot 스케줄러에 의해 호출되는 뉴스 생성 엔드포인트"""
    try:
        # LangChain 서비스를 통해 Claude 웹 검색 및 뉴스 생성 실행
        generated_news_list = await langchain_service.create_news_via_claude()
        
        # 생성된 뉴스를 DB에 저장
        await db_service.save_generated_news(generated_news_list)
        
        return {"status": "success", "generated_count": len(generated_news_list)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

**3.3. 온디맨드 북마크 모니터링 API (`POST /run-monitoring`)**

*   **역할:** Spring Boot의 스케줄링 요청에 따라, 활성화된 모든 북마크에 대한 최신 변경사항을 감지하고 `update_feeds` 테이블에 기록.
*   **구현 방안:**
    1.  **FastAPI 엔드포인트 생성:** `POST /run-monitoring`
    2.  **핵심 모니터링 로직:**
        a. DB에서 알림이 활성화된 모든 `bookmarks`를 조회합니다.
        b. 각 북마크를 순회하며 `targetValue`(예: HSCode)를 키워드로, 네이티브 검색 기능이 활성화된 Claude 모델을 호출합니다.
        c. **동적 프롬프트 사용:**
           ```prompt
           f"Find any updates (news, regulation changes, tariff adjustments) related to '{bookmark.target_value}' within the last 24 hours. If you find any, summarize the key change in one sentence in Korean."
           ```
        d. 변경 사항이 감지되면, Claude가 생성한 요약문을 `update_feeds` 테이블에 저장합니다.
*   **관련 데이터베이스 테이블:**
    <details>
    <summary><code>bookmarks</code> 테이블 스키마 보기</summary>

    ```sql
    -- 타입 정의
    CREATE TYPE bookmark_type AS ENUM ('HS_CODE', 'CARGO');

    -- 테이블 생성
    CREATE TABLE bookmarks (
        id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
        user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        type bookmark_type NOT NULL,
        target_value VARCHAR(50) NOT NULL,
        display_name VARCHAR(200) NULL,
        sse_generated BOOLEAN NOT NULL DEFAULT FALSE,
        sse_event_data JSONB NULL,
        sms_notification_enabled BOOLEAN NOT NULL DEFAULT FALSE,
        email_notification_enabled BOOLEAN NOT NULL DEFAULT TRUE,
        monitoring_active BOOLEAN GENERATED ALWAYS AS (
            sms_notification_enabled OR email_notification_enabled
        ) STORED,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, target_value)
    );

    -- 주석 추가
    COMMENT ON TABLE bookmarks IS 'SSE 기반 동적 북마크 시스템';
    COMMENT ON COLUMN bookmarks.target_value IS 'HS Code 또는 화물관리번호';
    COMMENT ON COLUMN bookmarks.display_name IS '사용자 지정 표시명';
    COMMENT ON COLUMN bookmarks.sse_generated IS 'SSE 첫 번째 이벤트로 생성된 북마크 식별';
    COMMENT ON COLUMN bookmarks.sse_event_data IS 'Claude가 SSE로 전달한 북마크 생성 데이터';
    COMMENT ON COLUMN bookmarks.sms_notification_enabled IS '개별 SMS 알림';
    COMMENT ON COLUMN bookmarks.email_notification_enabled IS '개별 이메일 알림';
    COMMENT ON COLUMN bookmarks.monitoring_active IS '모니터링 활성화 상태 (알림 설정 기반 자동 계산)';
    ```
    </details>
    <details>
    <summary><code>update_feeds</code> 테이블 스키마 보기</summary>

    ```sql
    -- 타입 정의
    CREATE TYPE feed_type AS ENUM (
        'HS_CODE_TARIFF_CHANGE',
        'HS_CODE_REGULATION_UPDATE',
        'CARGO_STATUS_UPDATE',
        'TRADE_NEWS',
        'POLICY_UPDATE'
    );
    CREATE TYPE target_type AS ENUM ('HS_CODE', 'CARGO');
    CREATE TYPE importance_level AS ENUM ('HIGH', 'MEDIUM', 'LOW');

    -- 테이블 생성
    CREATE TABLE update_feeds (
        id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
        user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        feed_type feed_type NOT NULL,
        target_type target_type NULL,
        target_value VARCHAR(50) NULL,
        title VARCHAR(500) NOT NULL,
        content TEXT NOT NULL,
        source_url VARCHAR(1000) NULL,
        importance importance_level NOT NULL DEFAULT 'MEDIUM',
        is_read BOOLEAN NOT NULL DEFAULT FALSE,
        included_in_daily_notification BOOLEAN NOT NULL DEFAULT FALSE,
        daily_notification_sent_at TIMESTAMP NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    -- 주석 추가
    COMMENT ON TABLE update_feeds IS '업데이트 피드 - 일일 알림 시스템 지원';
    COMMENT ON COLUMN update_feeds.target_value IS '대상 HS Code 또는 화물관리번호';
    COMMENT ON COLUMN update_feeds.included_in_daily_notification IS '일일 알림 포함 여부';
    COMMENT ON COLUMN update_feeds.daily_notification_sent_at IS '일일 알림 발송 시간';
    ```
    </details>

```python
# app/api/v1/endpoints/monitoring.py
@router.post("/run-monitoring")
async def run_bookmark_monitoring():
    """Spring Boot 스케줄러에 의해 호출되는 북마크 모니터링 엔드포인트"""
    try:
        active_bookmarks = await db_service.get_active_bookmarks()
        update_count = 0
        for bookmark in active_bookmarks:
            # LangChain 서비스를 통해 북마크 관련 변경사항 감지 및 요약
            summary = await langchain_service.find_updates_for_bookmark(bookmark)
            if summary:
                await db_service.create_update_feed(bookmark, summary)
                update_count += 1
        return {"status": "success", "monitored_bookmarks": len(active_bookmarks), "updates_found": update_count}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

**3.4. 고급 기능: 멀티스텝(Multi-Step) 웹 검색 예시**

*   **개념:** 최신 Claude 모델(`claude-3-5-sonnet-latest` 등)은 복잡한 질문에 답변하기 위해 스스로 여러 단계의 웹 검색과 분석을 수행하는 **자율적 멀티스텝 추론(Autonomous Multi-Step Reasoning)** 능력을 갖추고 있습니다. 개발자는 복잡한 에이전트를 구성할 필요 없이, 단지 네이티브 웹 검색 도구를 모델에 바인딩하고 명확한 프롬프트를 제공하는 것만으로 이 강력한 기능을 활용할 수 있습니다.
*   **구현 방안:**
    1.  `LangChainService`에 네이티브 웹 검색 기능이 바인딩된 `llm_with_native_search` 모델을 그대로 사용합니다.
    2.  여러 정보 소스를 비교하고 종합해야 하는 복잡한 질문을 프롬프트로 전달합니다. 모델은 내부적으로 필요한 검색을 여러 번 수행하여 최종 답변을 도출합니다.

*   **예시 코드 (`app/services/langchain_service.py` 내 추가 메서드 예시):**

```python
# app/services/langchain_service.py 내에 추가될 수 있는 고급 분석 함수 예시
from langchain_core.messages import HumanMessage

async def get_multi_step_analysis(self, complex_question: str) -> str:
    """
    복잡한 질문에 대해 Claude의 자율적 멀티스텝 추론 및 웹 검색을 활용하여
    심층 분석 보고서를 생성합니다.
    """
    # 네이티브 검색 기능이 바인딩된 모델을 그대로 사용합니다.
    # 모델이 질문의 복잡성을 인지하고 스스로 여러 번의 검색을 수행합니다.
    response = await self.llm_with_native_search.ainvoke([
        HumanMessage(content=complex_question)
    ])
    
    # 모델의 응답에는 여러 검색 결과를 종합한 최종 분석 내용이 포함됩니다.
    # tool_calls를 확인하면 모델이 내부적으로 어떤 검색을 수행했는지 추적할 수 있습니다.
    print("AI가 내부적으로 수행한 도구 호출(검색) 내역:", response.tool_calls)
    
    return response.content

# 위 함수를 호출하는 예시
# analysis = await langchain_service.get_multi_step_analysis(
#     "Compare the main new features of Python 3.12 and Go 1.22, "
#     "and summarize the key differences for web backend development."
# )
# print(analysis)
```

---

#### **4. Spring Boot 연동 방안 (최종)**

Spring Boot는 이제 Python 서버에 작업을 '지시'하는 명확한 역할을 갖습니다.

**Spring Boot `BackgroundJobScheduler` 예시 (Kotlin)**
```kotlin
@Component
class BackgroundJobScheduler(private val webClient: WebClient) {

    private val pythonServerUrl = "http://python-fastapi-server:8000"

    // 매시간 정각에 뉴스 생성 요청
    @Scheduled(cron = "0 0 * * * *")
    fun triggerNewsGeneration() {
        webClient.post()
            .uri("$pythonServerUrl/generate-news")
            .retrieve()
            .bodyToMono(String::class.java)
            .doOnSuccess { result -> logger.info("뉴스 생성 작업 요청 성공: $result") }
            .doOnError { e -> logger.error("뉴스 생성 작업 요청 실패", e) }
            .subscribe()
    }

    // 매일 새벽 5시에 모니터링 요청
    @Scheduled(cron = "0 0 5 * * *")
    fun triggerBookmarkMonitoring() {
        webClient.post()
            .uri("$pythonServerUrl/run-monitoring")
            .retrieve()
            .bodyToMono(String::class.java)
            .doOnSuccess { result -> logger.info("북마크 모니터링 작업 요청 성공: $result") }
            .doOnError { e -> logger.error("북마크 모니터링 작업 요청 실패", e) }
            .subscribe()
    }
}
```

---

#### **5. 최종 결론**

이 아키텍처는 각 서버의 역할을 명확히 분리하여 얻는 이점이 매우 큽니다.

*   **단순성 및 예측 가능성:** Python 서버는 API 명세에 따라 요청/응답만 처리하면 되므로 로직이 단순해집니다.
*   **중앙 집중 제어:** Spring Boot 서버에서 모든 백그라운드 작업의 시점과 주기를 관리하므로, 전체 시스템의 동작을 파악하고 제어하기 용이합니다.
*   **확장성:** 향후 Python 서버의 부하가 커지면 해당 인스턴스만 독립적으로 증설하면 되며, Spring Boot의 스케줄링 로직은 변경할 필요가 없습니다.

이 최종 전략에 따라 개발을 진행하시면, 기술적으로 매우 정제되고 안정적이며, 유지보수가 용이한 고품질 플랫폼을 구축하실 수 있을 것입니다.